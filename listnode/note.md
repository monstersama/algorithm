#链表
### 特点
1. 非连续的内存空间，通过指针将一组零散的内存空间组合起来
2. 支持数据的查找、插入和删除
3. 单纯插入和删除操作时间复杂度为**O(1)**，但随机访问第k个元素的时间复杂度为**O(n)**

### 链表的种类
1. 单链表
    ![](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)
2. 循环链表
    ![](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)
    -  适合处理环形数据([约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98))
3. 双向链表
    ![](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)
    - 双向链表在每个节点前面增加了一个前驱指针prev，指向前一个节点
    - 指定结点的删除操作时间复杂度为**O(1)**，插入指定结点前时间复杂度为**O(1)**
    - 对于有序链表查询效率更高

### 链表技巧
1. 理解指针或引用。  
    将某个变量赋值给指针，就是把变量的地址赋值给指针。也就是指针存储的是变量的地址
    指向这个变量，通过指针就能找到这个变量。

2. 注意指针丢失和内存泄露。  
    - 在一个单链表中在a,b节点中插入一个新的节点x，注意指针修改的顺讯  
        ```
        x->next = p->next; 
        p->next = x;
        ``` 
        
3. 利用哨兵简化实现难度主要是用在边界条件的检查
    - 比如在空链表中插入第一个结点
        ```
        if (head == null) {
            head = new_node;
        }
        ```
    - 常规的删除一个结点
        ```
        p->next = p->next->next;
        ```
    - 删除最后一个结点
        ```
        if (head->next == null) {
            head = null;
        }
        ```
   - 引入哨兵结点后，head指针将一直指向这个哨兵结点，带有哨兵结点的链表也叫*带头链表*

4. 留意边界条件
    - 链表为空时代码能否正常工作
    - 链表只包含一个结点时能否正常工作
    - 链表只包含两个结点时能否正常工作
    - 代码逻辑处理头结点、尾结点是否正常
    - ...

5. 常见链表的操作练习
    - 单链表反转
    - 链表中环的检测
    - 两个有序链表合并
    - 删除链表倒数第n个结点
    - 求链表的中间结点